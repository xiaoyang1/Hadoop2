这个需求是用来学习辅助排序和二次排序的：
订单 id 商品 id 成交金额
0000001 Pdt_01 222.8
0000001 Pdt_06 25.8
0000002 Pdt_03 522.8
0000002 Pdt_04 122.4
0000002 Pdt_05 722.4
0000003 Pdt_01 222.8
0000003 Pdt_02 33.8


主要有以下需求： 求出每一个订单中最贵的商品
思路：

利用“订单 id 和成交金额”作为 key，可以将 map 阶段读取到的所有订单数据按照id分区，按照金额进行排序，发送到reduce。

在 reduce 端利用 groupingcomparator 将订单 id 相同的 kv 聚合成组，然后取第一
个即是最大值。

分区的时候是key 的第一次排序，也就是分组用的排序，
key二次排序其实就是在compare的地方比较两次，先比id，再比较值。二次排序后，需要重新定义分区类，否则将会出现问题：
比如，0000003 Pdt_01 222.8
   0000003 Pdt_02 33.8 这两条数据，如果不修改分区，在map阶段，shuffle 溢写的时候会排序，merge的时候也会排序和combiner，
   如果不重写分区， 会根据序列化对象的原生hashcode（）去分区，这样就不能保证同一个id的在一起。


区别： bean中的compareTo 是在溢出和merge 时用来排序的。
GroupingComparator是在reduce阶段分组来使用的，由于reduce阶段，
如果key相同的一组，只取第一个key作为key，迭代所有的values。  这样，由于id相同的都在同一个分区，这样保证了
所有相同id的map结果由同一个reduce来完成。 这样在reduce阶段，就会把只取第一个key，其他的只是把值加上，
但是由于在reduce端merge时调用compareTo排好序，所以第一个就保证了是最大的。